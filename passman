#!/usr/bin/env bash
# password management script 
# Copyright 2016 prussian <generalunrest@airmail.cc>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

PASSWORD_ROOT="$HOME/.passman_passwords"

# HELPER FUNCTIONS

# terminate program with message
die() {
	echo -e "$@"
	exit 1
}

# save user identity variable
init_pass() {
	read -p "enter an identity to use: " USER_IDENT 

	# check if an identity exists
	gpg --list-key $USER_IDENT >/dev/null 
	# if an identity exists
	if [[ $? -eq 0 ]]; then
		# save identity
		echo "USER_IDENT=$USER_IDENT"\
			 > $PASSWORD_ROOT/.passman.conf
	else
		die "failed to init" \
			"\n${USER_IDENT} is not a valid identity"
	fi
}

decrypt_pass() {
	gpg --decrypt "${PASSWORD_ROOT}/${1}" 2>/dev/null
}

encrypt_pass_tofile() {
	gpg \
		--encrypt \
		--recipient $USER_IDENT \
		<<< "$1" \
		> "${PASSWORD_ROOT}/${2}"
	echo ""
}

# extracts the directory path
get_dir() {
	sed 's|\(.*\)/.*|\1|g' <<< "$1"
}



# save password at given path
encrypt_pass() {
	# escape double dots
	arg_path=${1//./\\.}

	# check if arg was given
	[[ -z $1 ]] && die "no argument given"

	# check if arg is a dir
	[[ -d ${PASSWORD_ROOT}/${arg_path} ]] \
		&& die "argument is a directory"

	# create dir if it doesn't exist
	dir_path=`get_dir ${PASSWORD_ROOT}/${arg_path}`
	if [[ ! -d "$dir_path" ]];then 
		mkdir -p $dir_path
		# mkdir failed for some reason? exit
		[[ $? -gt 0 ]] \
			&& die "could not create directory structure"
	fi

	read -s -p "enter password to store: " password
	# save password to file at given path
	encrypt_pass_tofile "$password" "$arg_path"
}

list_passwords() {
	tree --noreport $PASSWORD_ROOT 2>/dev/null
	# if tree command not found run ls recursively
	[[ $? -gt 0 ]] && ls -R $PASSWORD_ROOT
}

# START OF PROGRAM

if [[ "$1" == "init" ]]; then
	rm -rf $PASSWORD_ROOT
	mkdir $PASSWORD_ROOT
	init_pass
	exit 0
fi

# get user identity set at init
if [[ -d "$PASSWORD_ROOT" ]]; then
	if [[ -f "$PASSWORD_ROOT/.passman.conf" ]]; then
		. ${PASSWORD_ROOT}/.passman.conf
	else
		echo "Initializing password manager..."
		init_pass
	fi
else
	echo "Initializing password manager..."
	mkdir $PASSWORD_ROOT
	init_pass
fi

case $1 in
	new|create)
		# if file already exists, exit
		[[ -f "${PASSWORD_ROOT}/${2//./\\.}" ]] &&\
			die "password already exists" \
				"\nuse the set command to change it"
		encrypt_pass $2
		;;
	get)
		decrypt_pass $2
		;;
	set)
		# don't care if file exists or not
		encrypt_pass $2
		;;
	del|remove)
		rm ${PASSWORD_ROOT}/$2
		;;
	ls|list)
		list_passwords
		;;
	*)
		echo "Usage: $0 command <path/to/password/file>"
		echo ""
		echo "  command | new    - create a new password entry"
		echo "          | get    - get a password"
		echo "          | set    - set a password"
		echo "          | del    - remove a password"
		echo "          | ls     - list all passwords"
		echo "          | init   - reset manager"
		;;
esac
