#!/usr/bin/env bash
# password management script 
# Copyright 2016 prussian <generalunrest@airmail.cc>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

PASSWORD_ROOT="$HOME/.passman_passwords"
GPG=gpg2

# HELPER FUNCTIONS

# terminate program with message
die() {
	echo -e "$@"
	exit 1
}

# save user identity variable
init_pass() {
	mkdir $PASSWORD_ROOT
	read -p "enter an identity to use: " USER_IDENT 
	read -p "enter git address (leave empty to remove syncing): " GIT_PATH 

	# clone passwords from git if provided
    if [[ -n "$GIT_PATH" ]]; then
		git clone "$GIT_PATH" "$PASSWORD_ROOT"
    fi
	# check if an identity exists
	$GPG --list-key $USER_IDENT > /dev/null 
	# if an identity exists
	if [[ $? -eq 0 ]]; then
		# save identity
		( 
            echo "USER_IDENT=${USER_IDENT}"
            echo "GIT_PATH=${GIT_PATH}"
        ) > $PASSWORD_ROOT/.passman.conf
	else
		die "failed to init" \
			"\n${USER_IDENT} is not a valid identity"
	fi
}

git_check_update() {
	[[ -n "$GIT_PATH" ]] && (
		echo "checking for git changes..."
		git pull > /dev/null
	)
}

# $1 message
# $2 changed file
git_push_change() {
	[[ -n "$GIT_PATH" ]] && (
		echo "syncing changes... "
		echo "$1 $2"
		cd $PASSWORD_ROOT
		git add .
		git commit -m "$1 $2" > /dev/null
		git push > /dev/null
    )
}

decrypt_pass() {
	$GPG \
		--armor \
		--decrypt \
		"${PASSWORD_ROOT}/${1}" \
		2>/dev/null
}

encrypt_pass_tofile() {
	echo ""
	git_check_update
	$GPG \
		--armor \
		--encrypt \
		--recipient $USER_IDENT \
		<<< "$1" \
		> "${PASSWORD_ROOT}/${2}"
	echo ""
	git_push_change "added:" "$2"
}

delete_pass() {
	git_check_update
	rm -rf "${PASSWORD_ROOT}/${1}"
	git_push_change "removed:" "$1"
}

# extracts the directory path
get_dir() {
	sed 's|\(.*\)/.*|\1|g' <<< "$1"
}

# save password at given path
encrypt_pass() {
	# check if arg was given
	[[ -z $1 ]] && die "no argument given"

	# check if arg is a dir
	[[ -d ${PASSWORD_ROOT}/${1} ]] \
		&& die "argument is a directory"

	# create dir if it doesn't exist
	dir_path=`get_dir "${PASSWORD_ROOT}/${1}"`
	if [[ ! -d "$dir_path" ]];then 
		mkdir -p $dir_path 2> /dev/null
		# mkdir failed for some reason? exit
		[[ $? -gt 0 ]] \
			&& die "could not create directory structure"
	fi

	read -s -p "enter password to store: " password
	# save password to file at given path
	encrypt_pass_tofile "$password" "$1"
}

list_passwords() {
	tree --noreport $PASSWORD_ROOT 2>/dev/null
	# if tree command not found run ls recursively
	[[ $? -gt 0 ]] && ls -R $PASSWORD_ROOT
}

# START OF PROGRAM

if [[ "$1" == "init" ]]; then
	rm -rf $PASSWORD_ROOT
	init_pass
	exit 0
fi

# get user identity set at init
if [[ -d "$PASSWORD_ROOT" ]]; then
	if [[ -f "$PASSWORD_ROOT/.passman.conf" ]]; then
		. ${PASSWORD_ROOT}/.passman.conf
	else
		echo "Initializing password manager..."
		init_pass
	fi
else
	echo "Initializing password manager..."
	init_pass
fi

case $1 in
	new|create)
		# if file already exists, exit
		[[ -f "${PASSWORD_ROOT}/${2//./\\.}" ]] &&\
			die "password already exists" \
				"\nuse the set command to change it"
		encrypt_pass ${2//./\\.}
		;;
	get)
		decrypt_pass ${2//./\\.}
		;;
	set)
		# don't care if file exists or not
		encrypt_pass ${2//./\\.}
		;;
	del|remove)
		delete_pass ${2//./\\.}
		;;
	ls|list)
		list_passwords
		;;
	*)
		echo "Usage: $0 command <path/to/password/file>"
		echo ""
		echo "  command | new    - create a new password entry"
		echo "          | get    - get a password"
		echo "          | set    - set a password"
		echo "          | del    - remove a password"
		echo "          | ls     - list all passwords"
		echo "          | init   - reset manager"
		;;
esac
